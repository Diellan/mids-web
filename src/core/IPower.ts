// Converted from C# IPower.cs
// Note: IComparable is C# specific. In TypeScript, we can implement comparison methods directly.
// Note: BinaryWriter is C# specific. A TypeScript replacement is needed (see Utils/BinaryWriter.ts).

import { Requirement } from './Requirement';
import { IEffect } from './IEffect';
import { IPowerset } from './IPowerset';
import { Archetype } from './Base/Data_Classes/Archetype';
import { SummonedEntity } from './SummonedEntity';
import * as Enums from './Enums';
import { BinaryWriter } from 'csharp-binary-stream';

export interface IPower {
    HasProcSlotted: boolean;
    FullSetName: string;

    CastTime: number;
    CastTimeReal: number;
    ToggleCost: number;
    IsEpic: boolean;
    Slottable: boolean;
    MaxSlots: number;
    LocationIndex: number;
    IsModified: boolean;
    IsNew: boolean;
    PowerIndex: number;
    PowerSetID: number;
    PowerSetIndex: number;
    HasAbsorbedEffects: boolean;
    StaticIndex: number;
    NGroupMembership: number[];
    FullName: string;
    GroupName: string;
    SetName: string;
    PowerName: string;
    DisplayName: string;
    Available: number;
    Requires: Requirement;
    ModesRequired: Enums.eModeFlags;
    ModesDisallowed: Enums.eModeFlags;
    PowerType: Enums.ePowerType;
    Accuracy: number;
    AccuracyMult: number;
    AttackTypes: Enums.eVector;
    GroupMembership: string[];
    EntitiesAffected: Enums.eEntity;
    EntitiesAutoHit: Enums.eEntity;
    Target: Enums.eEntity;
    TargetLoS: boolean;
    Range: number;
    TargetSecondary: Enums.eEntity;
    RangeSecondary: number;
    EndCost: number;
    InterruptTime: number;
    RechargeTime: number;
    BaseRechargeTime: number;
    ActivatePeriod: number;
    EffectArea: Enums.eEffectArea;
    Radius: number;
    AoEModifier: number;
    Arc: number;
    MaxTargets: number;
    MaxBoosts: string;
    CastFlags: Enums.eCastFlags;
    AIReport: Enums.eNotify;
    NumCharges: number;
    UsageTime: number;
    LifeTime: number;
    LifeTimeInGame: number;
    NumAllowed: number;
    DoNotSave: boolean;
    BoostsAllowed: string[];
    Enhancements: number[];
    CastThroughHold: boolean;
    IgnoreStrength: boolean;
    DescShort: string;
    DescLong: string;
    SortOverride: boolean;
    HiddenPower: boolean;
    SetTypes: number[];
    ClickBuff: boolean;
    AlwaysToggle: boolean;
    Level: number;
    AllowFrontLoading: boolean;
    VariableEnabled: boolean;
    VariableOverride: boolean;
    VariableName: string;
    VariableMin: number;
    VariableMax: number;
    VariableStart: number;
    NIDSubPower: number[];
    UIDSubPower: string[];
    SubIsAltColor: boolean;
    IgnoreEnh: Enums.eEnhance[];
    Ignore_Buff: Enums.eEnhance[];
    SkipMax: boolean;
    DisplayLocation: number;
    MutexAuto: boolean;
    MutexIgnore: boolean;
    AbsorbSummonEffects: boolean;
    AbsorbSummonAttributes: boolean;
    ShowSummonAnyway: boolean;
    NeverAutoUpdate: boolean;
    NeverAutoUpdateRequirements: boolean;
    IncludeFlag: boolean;
    BoostBoostable: boolean;
    BoostUsePlayerLevel: boolean;
    ForcedClass: string;
    InherentType: Enums.eGridType;
    ForcedClassID: number;
    Effects: IEffect[];
    BuffMode: Enums.eBuffMode;
    HasGrantPowerEffect: boolean;
    HasPowerOverrideEffect: boolean;
    Active: boolean;
    Taken: boolean;
    Stacks: number;
    AppliedExecutes: boolean;
    CastTimeBase: number;
    ArcanaCastTime: number;
    IsSummonPower: boolean;
    IsPetPower: boolean;
    DescLongFormatted: string;
    CSPrimaryKey: string | null;

    GetPowerSet(): IPowerset | null;
    StoreTo(writer: BinaryWriter): void;
    FXGetDamageValue(absorb?: boolean): number;
    GetDamageTip(): string;
    FXGetDamageString(absorb?: boolean): string;
    GetRankedEffects(newMode: boolean): number[];
    GetDurationEffectID(): number;
    GetRes(pvE?: boolean): number[];
    HasMutexID(index: number): boolean;
    GetEntities(): SummonedEntity[] | null;
    HasAttribModEffects(): boolean;
    GetEnhancementMagSum(iEffect: Enums.eEffectType, subType?: number): Enums.ShortFX;
    GetEffectMagSum(iEffect: Enums.eEffectType, includeDelayed?: boolean, onlySelf?: boolean, onlyTarget?: boolean, maxMode?: boolean): Enums.ShortFX;
    GetEffectMagSum(iEffect: Enums.eEffectType, etModifies: Enums.eEffectType, damageType: Enums.eDamage, mezType: Enums.eMez, includeDelayed?: boolean, onlySelf?: boolean, onlyTarget?: boolean, maxMode?: boolean): Enums.ShortFX;
    GetDamageMagSum(iEffect: Enums.eEffectType, iSub: Enums.eDamage, includeDelayed?: boolean): Enums.ShortFX;
    GetEffectMag(iEffect: Enums.eEffectType, iTarget?: Enums.eToWho, allowDelay?: boolean): Enums.ShortFX;
    AffectsTarget(iEffect: Enums.eEffectType): boolean;
    I9FXPresentP(iEffect: Enums.eEffectType, iMez?: Enums.eMez): boolean;
    IgnoreEnhancement(iEffect: Enums.eEnhance): boolean;
    IgnoreBuff(iEffect: Enums.eEnhance): boolean;
    SetMathMag(): void;
    GetEffectStringGrouped(idEffect: number, returnString: { value: string }, returnMask: { value: number[] }, shortForm: boolean, simple: boolean, noMag?: boolean, fromPopup?: boolean, ignoreConditions?: boolean): boolean;
    AbsorbEffects(source: IPower | null, nDuration: number, nDelay: number, archetype: Archetype | null, stacking: number, isGrantPower?: boolean, fxid?: number, effectId?: number): number[];
    ApplyGrantPowerEffects(): void;
    GetValidEnhancements(iType: Enums.eType, iSubType?: number): number[];
    IsEnhancementValid(iEnh: number): boolean;
    AbsorbPetEffects(hIdx?: number, stackingOverride?: number): void;
    AllowedForClass(classId: number): boolean;
    ProcessExecutes(): void;
    BuildTooltipStringAllVectorsEffects(effectType: Enums.eEffectType, etModifies: Enums.eEffectType, damageType: Enums.eDamage, mezType: Enums.eMez, groupName?: string, includeEnhEffects?: boolean): string;
    GetDifferentAttributesSubPower(fxIndex: number): string;
    ApplyModifyEffects(): void;
    ExportToJson(): string;
}

